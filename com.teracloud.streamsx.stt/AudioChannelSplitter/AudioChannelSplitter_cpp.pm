
package AudioChannelSplitter_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
       # Get operator parameters with defaults
       my $stereoFormatParam = $model->getParameterByName("stereoFormat");
       my $stereoFormat = $stereoFormatParam ? 
           $stereoFormatParam->getValueAt(0)->getCppExpression() : '"interleaved"';
           
       my $encodingParam = $model->getParameterByName("encoding");
       my $encoding = $encodingParam ? 
           $encodingParam->getValueAt(0)->getCppExpression() : '"pcm16"';
           
       my $leftChannelRoleParam = $model->getParameterByName("leftChannelRole");
       my $leftChannelRole = $leftChannelRoleParam ? 
           $leftChannelRoleParam->getValueAt(0)->getCppExpression() : '"caller"';
           
       my $rightChannelRoleParam = $model->getParameterByName("rightChannelRole");
       my $rightChannelRole = $rightChannelRoleParam ? 
           $rightChannelRoleParam->getValueAt(0)->getCppExpression() : '"agent"';
           
       my $sampleRateParam = $model->getParameterByName("sampleRate");
       my $sampleRate = $sampleRateParam ? 
           $sampleRateParam->getValueAt(0)->getCppExpression() : '8000';
           
       my $targetSampleRateParam = $model->getParameterByName("targetSampleRate");
       my $targetSampleRate = $targetSampleRateParam ? 
           $targetSampleRateParam->getValueAt(0)->getCppExpression() : '0';
           
       # Get port schemas to understand tuple structure
       my $iport0 = $model->getInputPortAt(0);
       my $oport0 = $model->getOutputPortAt(0);
       my $oport1 = $model->getOutputPortAt(1);
   print "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '    : leftChannelRole_(';
   print $leftChannelRole;
   print '),', "\n";
   print '      rightChannelRole_(';
   print $rightChannelRole;
   print '),', "\n";
   print '      stereoFormat_(';
   print $stereoFormat;
   print '),', "\n";
   print '      encoding_(';
   print $encoding;
   print '),', "\n";
   print '      sampleRate_(';
   print $sampleRate;
   print '),', "\n";
   print '      targetSampleRate_(';
   print $targetSampleRate;
   print '),', "\n";
   print '      tuplesProcessed_(0),', "\n";
   print '      bytesProcessed_(0)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter constructor", SPL_OPER_DBG);', "\n";
   print '    SPLAPPTRC(L_INFO, "Configuration - format: " << stereoFormat_ ', "\n";
   print '              << ", encoding: " << encoding_', "\n";
   print '              << ", sampleRate: " << sampleRate_, SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter destructor - processed " ', "\n";
   print '              << tuplesProcessed_ << " tuples, " ', "\n";
   print '              << bytesProcessed_ << " bytes", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_INFO, "AudioChannelSplitter ready", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter shutdown", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Process incoming tuples', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    const IPort0Type & ituple = static_cast<const IPort0Type &>(tuple);', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        // Get audio data and timestamp from input tuple', "\n";
   print '        // Assumes input has audioData (blob) and audioTimestamp (uint64) attributes', "\n";
   print '        const SPL::blob& audioData = ituple.get_audioData();', "\n";
   print '        uint64_t audioTimestamp = ituple.get_audioTimestamp();', "\n";
   print '        ', "\n";
   print '        // Process the stereo audio', "\n";
   print '        processStereoAudioBlob(audioData, audioTimestamp);', "\n";
   print '        ', "\n";
   print '        tuplesProcessed_++;', "\n";
   print '        bytesProcessed_ += audioData.getSize();', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Failed to process audio tuple: " << e.what(), SPL_OPER_DBG);', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print '// Process punctuation', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter received punctuation: " << punct, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Forward punctuation to both output ports', "\n";
   print '    submit(punct, 0);  // Left channel', "\n";
   print '    submit(punct, 1);  // Right channel', "\n";
   print '}', "\n";
   print "\n";
   print '// Process stereo audio blob', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processStereoAudioBlob(const SPL::blob& audioData, uint64_t audioTimestamp)', "\n";
   print '{', "\n";
   print '    using namespace com::teracloud::streamsx::stt;', "\n";
   print '    ', "\n";
   print '    const uint8_t* data = audioData.getData();', "\n";
   print '    size_t dataSize = audioData.getSize();', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_TRACE, "Processing stereo audio: " << dataSize << " bytes", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        StereoAudioSplitter::ChannelBuffers channels;', "\n";
   print '        StereoAudioSplitter::SplitOptions options;', "\n";
   print '        options.sourceSampleRate = sampleRate_;', "\n";
   print '        options.targetSampleRate = targetSampleRate_;', "\n";
   print '        options.normalizeFloat = false;  // Keep as PCM values', "\n";
   print '        ', "\n";
   print '        // Split based on encoding type', "\n";
   print '        if (encoding_ == "pcm16") {', "\n";
   print '            const int16_t* pcmData = reinterpret_cast<const int16_t*>(data);', "\n";
   print '            size_t numSamples = dataSize / sizeof(int16_t);', "\n";
   print '            channels = StereoAudioSplitter::splitInterleavedPCM16(pcmData, numSamples, options);', "\n";
   print '        } else if (encoding_ == "pcm8") {', "\n";
   print '            size_t numSamples = dataSize;', "\n";
   print '            channels = StereoAudioSplitter::splitInterleavedPCM8(data, numSamples, options);', "\n";
   print '        } else if (encoding_ == "ulaw") {', "\n";
   print '            channels = StereoAudioSplitter::splitG711uLaw(data, dataSize, ', "\n";
   print '                                                          stereoFormat_ == "interleaved");', "\n";
   print '        } else if (encoding_ == "alaw") {', "\n";
   print '            channels = StereoAudioSplitter::splitG711aLaw(data, dataSize, ', "\n";
   print '                                                          stereoFormat_ == "interleaved");', "\n";
   print '        } else {', "\n";
   print '            SPLAPPTRC(L_ERROR, "Unsupported encoding: " << encoding_, SPL_OPER_DBG);', "\n";
   print '            return;', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        // Output the separated channels', "\n";
   print '        outputChannelData(channels.left, leftChannelRole_, 0, audioTimestamp, 0);', "\n";
   print '        outputChannelData(channels.right, rightChannelRole_, 1, audioTimestamp, 1);', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Error splitting audio: " << e.what(), SPL_OPER_DBG);', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print '// Output channel data to the appropriate port', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::outputChannelData(const std::vector<float>& channelData, ', "\n";
   print '                                    const std::string& channelRole,', "\n";
   print '                                    int32_t channelNumber,', "\n";
   print '                                    uint64_t audioTimestamp,', "\n";
   print '                                    uint32_t outputPort)', "\n";
   print '{', "\n";
   print '    // Convert float samples back to blob', "\n";
   print '    SPL::blob outputBlob = floatVectorToBlob(channelData, encoding_);', "\n";
   print '    ', "\n";
   print '    // Create output tuple - assumes output schema is ChannelAudioStream', "\n";
   print '    if (outputPort == 0) {', "\n";
   print '        OPort0Type otuple;', "\n";
   print '        ', "\n";
   print '        // Set the audio data', "\n";
   print '        otuple.set_audioData(outputBlob);', "\n";
   print '        ', "\n";
   print '        // Set the timestamp', "\n";
   print '        otuple.set_audioTimestamp(audioTimestamp);', "\n";
   print '        ', "\n";
   print '        // Set channel metadata (nested tuple)', "\n";
   print '        otuple.get_channelInfo().set_channelNumber(channelNumber);', "\n";
   print '        otuple.get_channelInfo().set_channelRole(channelRole);', "\n";
   print '        ', "\n";
   print '        // Set audio format info', "\n";
   print '        otuple.set_sampleRate(targetSampleRate_ > 0 ? targetSampleRate_ : sampleRate_);', "\n";
   print '        otuple.set_bitsPerSample(16);  // Output is always 16-bit PCM', "\n";
   print '        ', "\n";
   print '        submit(otuple, 0);', "\n";
   print '    } else {', "\n";
   print '        OPort1Type otuple;', "\n";
   print '        ', "\n";
   print '        // Set the audio data', "\n";
   print '        otuple.set_audioData(outputBlob);', "\n";
   print '        ', "\n";
   print '        // Set the timestamp', "\n";
   print '        otuple.set_audioTimestamp(audioTimestamp);', "\n";
   print '        ', "\n";
   print '        // Set channel metadata (nested tuple)', "\n";
   print '        otuple.get_channelInfo().set_channelNumber(channelNumber);', "\n";
   print '        otuple.get_channelInfo().set_channelRole(channelRole);', "\n";
   print '        ', "\n";
   print '        // Set audio format info', "\n";
   print '        otuple.set_sampleRate(targetSampleRate_ > 0 ? targetSampleRate_ : sampleRate_);', "\n";
   print '        otuple.set_bitsPerSample(16);  // Output is always 16-bit PCM', "\n";
   print '        ', "\n";
   print '        submit(otuple, 1);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_TRACE, "Output " << channelData.size() << " samples to port " ', "\n";
   print '              << outputPort << " (role: " << channelRole << ")", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Convert float vector to blob based on encoding', "\n";
   print 'SPL::blob MY_OPERATOR_SCOPE::MY_OPERATOR::floatVectorToBlob(const std::vector<float>& samples, ', "\n";
   print '                                         const std::string& encoding)', "\n";
   print '{', "\n";
   print '    // Always output as PCM16 regardless of input encoding', "\n";
   print '    std::vector<int16_t> pcm16(samples.size());', "\n";
   print '    for (size_t i = 0; i < samples.size(); ++i) {', "\n";
   print '        // Clamp to valid range', "\n";
   print '        float sample = samples[i];', "\n";
   print '        if (sample > 32767.0f) sample = 32767.0f;', "\n";
   print '        if (sample < -32768.0f) sample = -32768.0f;', "\n";
   print '        pcm16[i] = static_cast<int16_t>(sample);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    return SPL::blob(reinterpret_cast<const uint8_t*>(pcm16.data()), ', "\n";
   print '                    pcm16.size() * sizeof(int16_t));', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
