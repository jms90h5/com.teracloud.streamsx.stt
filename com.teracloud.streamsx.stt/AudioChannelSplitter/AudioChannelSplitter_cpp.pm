
package AudioChannelSplitter_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
       # Get operator parameters with defaults
       my $stereoFormatParam = $model->getParameterByName("stereoFormat");
       my $stereoFormat = $stereoFormatParam ? 
           $stereoFormatParam->getValueAt(0)->getCppExpression() : '"interleaved"';
           
       my $encodingParam = $model->getParameterByName("encoding");
       my $encoding = $encodingParam ? 
           $encodingParam->getValueAt(0)->getCppExpression() : '"pcm16"';
           
       my $leftChannelRoleParam = $model->getParameterByName("leftChannelRole");
       my $leftChannelRole = $leftChannelRoleParam ? 
           $leftChannelRoleParam->getValueAt(0)->getCppExpression() : '"caller"';
           
       my $rightChannelRoleParam = $model->getParameterByName("rightChannelRole");
       my $rightChannelRole = $rightChannelRoleParam ? 
           $rightChannelRoleParam->getValueAt(0)->getCppExpression() : '"agent"';
           
       my $sampleRateParam = $model->getParameterByName("sampleRate");
       my $sampleRate = $sampleRateParam ? 
           $sampleRateParam->getValueAt(0)->getCppExpression() : '8000';
           
       my $targetSampleRateParam = $model->getParameterByName("targetSampleRate");
       my $targetSampleRate = $targetSampleRateParam ? 
           $targetSampleRateParam->getValueAt(0)->getCppExpression() : '0';
   print "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   # Standard operator includes
   print '#include <SPL/Runtime/Operator/Operator.h>', "\n";
   print '#include <SPL/Runtime/Operator/ParameterValue.h>', "\n";
   print '#include <SPL/Runtime/Operator/OperatorContext.h>', "\n";
   print '#include <SPL/Runtime/Operator/OperatorMetrics.h>', "\n";
   print '#include <SPL/Runtime/Operator/Port/AutoPortMutex.h>', "\n";
   print '#include <SPL/Runtime/Operator/State/StateHandler.h>', "\n";
   print '#include <SPL/Runtime/ProcessingElement/PE.h>', "\n";
   print '#include <SPL/Runtime/Type/SPLType.h>', "\n";
   print '#include <SPL/Runtime/Utility/CV.h>', "\n";
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '    : leftChannelRole_(';
   print $leftChannelRole;
   print '),', "\n";
   print '      rightChannelRole_(';
   print $rightChannelRole;
   print '),', "\n";
   print '      stereoFormat_(';
   print $stereoFormat;
   print '),', "\n";
   print '      encoding_(';
   print $encoding;
   print '),', "\n";
   print '      sampleRate_(';
   print $sampleRate;
   print '),', "\n";
   print '      targetSampleRate_(';
   print $targetSampleRate;
   print '),', "\n";
   print '      tuplesProcessed_(0),', "\n";
   print '      bytesProcessed_(0)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter constructor", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter destructor - processed " ', "\n";
   print '              << tuplesProcessed_ << " tuples, " ', "\n";
   print '              << bytesProcessed_ << " bytes", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_INFO, "AudioChannelSplitter ready - "', "\n";
   print '              << "format=" << stereoFormat_ ', "\n";
   print '              << ", encoding=" << encoding_', "\n";
   print '              << ", sampleRate=" << sampleRate_ ', "\n";
   print '              << ", targetSampleRate=" << targetSampleRate_', "\n";
   print '              << ", leftRole=" << leftChannelRole_', "\n";
   print '              << ", rightRole=" << rightChannelRole_, ', "\n";
   print '              SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter shutdown", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Process incoming tuples', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    const IPort0Type & ituple = static_cast<const IPort0Type &>(tuple);', "\n";
   print '    ', "\n";
   print '    // Get audio data blob - look for first blob attribute', "\n";
   print '    // This is a simplified approach - in production, you might want to', "\n";
   print '    // specify the attribute name via a parameter', "\n";
   print '    SPL::blob audioData;', "\n";
   print '    uint64_t audioTimestamp = 0;', "\n";
   print '    ', "\n";
   print '    // Try to get common attribute names', "\n";
   print '    ';
     # Generate code to extract audio blob and timestamp
           # This is simplified - a real implementation would be more flexible
       
   print "\n";
   print '    try {', "\n";
   print '        // Get the audio data (assuming it\'s the first blob attribute)', "\n";
   print '        audioData = ituple.getAttributeValue(0).getBlob();', "\n";
   print '        ', "\n";
   print '        // Try to get audioTimestamp if available', "\n";
   print '        if (ituple.getNumberOfAttributes() > 1) {', "\n";
   print '            // Assuming second attribute might be audioTimestamp', "\n";
   print '            audioTimestamp = ituple.getAttributeValue(1).getUInt64();', "\n";
   print '        }', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Failed to extract audio data: " << e.what(), SPL_OPER_DBG);', "\n";
   print '        return;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Process the stereo audio', "\n";
   print '    processStereoAudioBlob(audioData, audioTimestamp);', "\n";
   print '    ', "\n";
   print '    tuplesProcessed_++;', "\n";
   print '    bytesProcessed_ += audioData.getSize();', "\n";
   print '}', "\n";
   print "\n";
   print '// Process punctuation', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "AudioChannelSplitter received punctuation: " << punct, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Forward punctuation to both output ports', "\n";
   print '    submit(punct, 0);  // Left channel', "\n";
   print '    submit(punct, 1);  // Right channel', "\n";
   print '}', "\n";
   print "\n";
   print '// Process stereo audio blob', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processStereoAudioBlob(const SPL::blob& audioData, uint64_t audioTimestamp)', "\n";
   print '{', "\n";
   print '    using namespace com::teracloud::streamsx::stt;', "\n";
   print '    ', "\n";
   print '    const uint8_t* data = audioData.getData();', "\n";
   print '    size_t dataSize = audioData.getSize();', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "Processing stereo audio: " << dataSize << " bytes", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        StereoAudioSplitter::ChannelBuffers channels;', "\n";
   print '        StereoAudioSplitter::SplitOptions options;', "\n";
   print '        options.sourceSampleRate = sampleRate_;', "\n";
   print '        options.targetSampleRate = targetSampleRate_;', "\n";
   print '        options.normalizeFloat = false;  // Keep as PCM values for now', "\n";
   print '        ', "\n";
   print '        // Split based on encoding type', "\n";
   print '        if (encoding_ == "pcm16") {', "\n";
   print '            const int16_t* pcmData = reinterpret_cast<const int16_t*>(data);', "\n";
   print '            size_t numSamples = dataSize / sizeof(int16_t);', "\n";
   print '            channels = StereoAudioSplitter::splitInterleavedPCM16(pcmData, numSamples, options);', "\n";
   print '        } else if (encoding_ == "pcm8") {', "\n";
   print '            size_t numSamples = dataSize;', "\n";
   print '            channels = StereoAudioSplitter::splitInterleavedPCM8(data, numSamples, options);', "\n";
   print '        } else if (encoding_ == "ulaw") {', "\n";
   print '            channels = StereoAudioSplitter::splitG711uLaw(data, dataSize, ', "\n";
   print '                                                          stereoFormat_ == "interleaved");', "\n";
   print '        } else if (encoding_ == "alaw") {', "\n";
   print '            channels = StereoAudioSplitter::splitG711aLaw(data, dataSize, ', "\n";
   print '                                                          stereoFormat_ == "interleaved");', "\n";
   print '        } else {', "\n";
   print '            SPLAPPTRC(L_ERROR, "Unsupported encoding: " << encoding_, SPL_OPER_DBG);', "\n";
   print '            return;', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        // Output the separated channels', "\n";
   print '        outputChannelData(channels.left, leftChannelRole_, 0, audioTimestamp, 0);', "\n";
   print '        outputChannelData(channels.right, rightChannelRole_, 1, audioTimestamp, 1);', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Error splitting audio: " << e.what(), SPL_OPER_DBG);', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print '// Output channel data to the appropriate port', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::outputChannelData(const std::vector<float>& channelData, ', "\n";
   print '                                    const std::string& channelRole,', "\n";
   print '                                    int32_t channelNumber,', "\n";
   print '                                    uint64_t audioTimestamp,', "\n";
   print '                                    uint32_t outputPort)', "\n";
   print '{', "\n";
   print '    // Convert float samples back to blob', "\n";
   print '    SPL::blob outputBlob = floatVectorToBlob(channelData, encoding_);', "\n";
   print '    ', "\n";
   print '    // Create output tuple based on the output port schema', "\n";
   print '    // This is simplified - actual implementation would match the exact schema', "\n";
   print '    if (outputPort == 0) {', "\n";
   print '        OPort0Type otuple;', "\n";
   print '        // Set attributes based on output schema', "\n";
   print '        // Assuming ChannelAudioStream type with audioData, timestamp, channelInfo', "\n";
   print '        otuple.setAttributeValue(0, outputBlob);  // audioData', "\n";
   print '        otuple.setAttributeValue(1, audioTimestamp);   // audioTimestamp', "\n";
   print '        ', "\n";
   print '        // Create channel metadata', "\n";
   print '        // This would need to match the actual ChannelMetadata type structure', "\n";
   print '        submit(otuple, 0);', "\n";
   print '    } else {', "\n";
   print '        OPort1Type otuple;', "\n";
   print '        otuple.setAttributeValue(0, outputBlob);  // audioData', "\n";
   print '        otuple.setAttributeValue(1, audioTimestamp);   // audioTimestamp', "\n";
   print '        submit(otuple, 1);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "Output " << channelData.size() << " samples to port " ', "\n";
   print '              << outputPort << " (role: " << channelRole << ")", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print '// Convert float vector to blob based on encoding', "\n";
   print 'SPL::blob MY_OPERATOR_SCOPE::MY_OPERATOR::floatVectorToBlob(const std::vector<float>& samples, ', "\n";
   print '                                         const std::string& encoding)', "\n";
   print '{', "\n";
   print '    if (encoding == "pcm16" || encoding == "ulaw" || encoding == "alaw") {', "\n";
   print '        // Convert float samples back to int16', "\n";
   print '        std::vector<int16_t> pcm16(samples.size());', "\n";
   print '        for (size_t i = 0; i < samples.size(); ++i) {', "\n";
   print '            // Assuming samples are already in PCM range, not normalized', "\n";
   print '            pcm16[i] = static_cast<int16_t>(samples[i]);', "\n";
   print '        }', "\n";
   print '        return SPL::blob(reinterpret_cast<const uint8_t*>(pcm16.data()), ', "\n";
   print '                        pcm16.size() * sizeof(int16_t));', "\n";
   print '    } else if (encoding == "pcm8") {', "\n";
   print '        // Convert to 8-bit PCM', "\n";
   print '        std::vector<uint8_t> pcm8(samples.size());', "\n";
   print '        for (size_t i = 0; i < samples.size(); ++i) {', "\n";
   print '            pcm8[i] = static_cast<uint8_t>(samples[i] + 128);', "\n";
   print '        }', "\n";
   print '        return SPL::blob(pcm8.data(), pcm8.size());', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Default: return empty blob', "\n";
   print '    return SPL::blob();', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
