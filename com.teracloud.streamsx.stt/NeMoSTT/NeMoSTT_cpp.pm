
package NeMoSTT_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
       # Get parameters
       my $modelPath = $model->getParameterByName("modelPath");
       my $tokensPath = $model->getParameterByName("tokensPath");
       my $audioFormat = $model->getParameterByName("audioFormat");
       my $chunkDurationMs = $model->getParameterByName("chunkDurationMs");
       my $minSpeechDurationMs = $model->getParameterByName("minSpeechDurationMs");
       
       # Get input/output ports
       my $inputPort = $model->getInputPortAt(0);
       my $outputPort = $model->getOutputPortAt(0);
   print "\n";
   print "\n";
   print '/* Additional includes for NeMoSTT operator */', "\n";
   print '#include <iostream>', "\n";
   print '#include <cstring>', "\n";
   print '#include <chrono>', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
       my $modelPathValue = $modelPath->getValueAt(0)->getCppExpression();
       my $tokensPathValue = $tokensPath->getValueAt(0)->getCppExpression();
       my $audioFormatValue = $audioFormat ? 'MY_OPERATOR_SCOPE::' . $audioFormat->getValueAt(0)->getSPLExpression() : 'MY_OPERATOR_SCOPE::mono16k';
       my $chunkDurationValue = $chunkDurationMs ? $chunkDurationMs->getValueAt(0)->getCppExpression() : "5000";
       my $minSpeechDurationValue = $minSpeechDurationMs ? $minSpeechDurationMs->getValueAt(0)->getCppExpression() : "500";
   print "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '    : sampleRate_(16000),', "\n";
   print '      channels_(1),', "\n";
   print '      modelPath_(';
   print $modelPathValue;
   print '),', "\n";
   print '      tokensPath_(';
   print $tokensPathValue;
   print '),', "\n";
   print '      chunkDurationMs_(';
   print $chunkDurationValue;
   print '),', "\n";
   print '      minSpeechDurationMs_(';
   print $minSpeechDurationValue;
   print ')', "\n";
   print '{', "\n";
   if ($audioFormat) {
   print "\n";
   print '    // Parse audio format', "\n";
   print '    MY_OPERATOR_SCOPE::AudioFormat format = ';
   print $audioFormatValue;
   print ';', "\n";
   print '    if (format == MY_OPERATOR_SCOPE::mono8k) {', "\n";
   print '        sampleRate_ = 8000;', "\n";
   print '    } else if (format == MY_OPERATOR_SCOPE::mono16k) {', "\n";
   print '        sampleRate_ = 16000;', "\n";
   print '    } else if (format == MY_OPERATOR_SCOPE::mono22k) {', "\n";
   print '        sampleRate_ = 22050;', "\n";
   print '    } else if (format == MY_OPERATOR_SCOPE::mono44k) {', "\n";
   print '        sampleRate_ = 44100;', "\n";
   print '    } else if (format == MY_OPERATOR_SCOPE::mono48k) {', "\n";
   print '        sampleRate_ = 48000;', "\n";
   print '    }', "\n";
   }
   print "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT constructor: modelPath=" << modelPath_ ', "\n";
   print '              << ", tokensPath=" << tokensPath_', "\n";
   print '              << ", sampleRate=" << sampleRate_ ', "\n";
   print '              << ", chunkDuration=" << chunkDurationMs_ << "ms"', "\n";
   print '              << ", minSpeechDuration=" << minSpeechDurationMs_ << "ms", ', "\n";
   print '              SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT destructor", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT allPortsReady", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        // Initialize NeMo CTC implementation', "\n";
   print '        nemoSTT_.reset(new NeMoCTCImpl());', "\n";
   print '        if (!nemoSTT_->initialize(modelPath_, tokensPath_)) {', "\n";
   print '            throw std::runtime_error("Failed to initialize NeMo CTC model");', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        SPLAPPTRC(L_INFO, "NeMo CTC model and feature extractor initialized successfully", SPL_OPER_DBG);', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Failed to initialize NeMo STT: " << e.what(), SPL_OPER_DBG);', "\n";
   print '        throw;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT prepareToShutdown", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_TRACE, "NeMoSTT process tuple", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    const IPort0Type & ituple = static_cast<const IPort0Type &>(tuple);', "\n";
   print '    ', "\n";
   print '    // Extract audio data from input tuple', "\n";
   print '    // Assuming the tuple has a blob attribute containing audio data', "\n";
   print '    // Extract audio data from input tuple (assumes first blob attribute is audio)', "\n";
   print '    const SPL::blob& audioBlob = ituple.get_audioChunk();', "\n";
   print '    const void* audioData = audioBlob.getData();', "\n";
   print '    uint64_t audioSize = audioBlob.getSize();', "\n";
   print '    ', "\n";
   print '    // Process audio data (assuming 16-bit samples)', "\n";
   print '    processAudioData(audioData, audioSize, 16);', "\n";
   print '    ', "\n";
   print '    // For streaming mode, could check if we have enough audio for transcription', "\n";
   print '    // For now, accumulate audio and transcribe on punctuation', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_INFO, "NeMoSTT process punctuation: " << punct, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // On window marker or final marker, flush any remaining audio and get final transcription', "\n";
   print '    if (punct == Punctuation::WindowMarker || punct == Punctuation::FinalMarker) {', "\n";
   print '        SPLAPPTRC(L_INFO, "Punctuation " << punct << " received. Audio buffer size: " << audioBuffer_.size() << " samples", SPL_OPER_DBG);', "\n";
   print '        ', "\n";
   print '        // Process any accumulated audio', "\n";
   print '        if (!audioBuffer_.empty()) {', "\n";
   print '            SPLAPPTRC(L_INFO, "Transcribing " << audioBuffer_.size() << " samples ("', "\n";
   print '                      << (audioBuffer_.size() * 1000.0f / sampleRate_) << " ms)", SPL_OPER_DBG);', "\n";
   print '            ', "\n";
   print '            std::string transcription = transcribeAudio(audioBuffer_);', "\n";
   print '            ', "\n";
   print '            SPLAPPTRC(L_INFO, "Transcription result: \'" << transcription << "\'", SPL_OPER_DBG);', "\n";
   print '            ', "\n";
   print '            if (!transcription.empty()) {', "\n";
   print '                outputTranscription(transcription);', "\n";
   print '            } else {', "\n";
   print '                SPLAPPTRC(L_INFO, "Empty transcription returned", SPL_OPER_DBG);', "\n";
   print '            }', "\n";
   print '            audioBuffer_.clear();', "\n";
   print '        } else {', "\n";
   print '            SPLAPPTRC(L_INFO, "Punctuation received but audio buffer is empty", SPL_OPER_DBG);', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Forward punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAudioData(const void* data, size_t bytes, int bitsPerSample)', "\n";
   print '{', "\n";
   print '    size_t samples = bytes / (bitsPerSample / 8);', "\n";
   print '    ', "\n";
   print '    // Convert to float samples and accumulate', "\n";
   print '    if (bitsPerSample == 16) {', "\n";
   print '        const int16_t* samples16 = static_cast<const int16_t*>(data);', "\n";
   print '        for (size_t i = 0; i < samples; i++) {', "\n";
   print '            audioBuffer_.push_back(samples16[i] / 32768.0f);', "\n";
   print '        }', "\n";
   print '    } else if (bitsPerSample == 8) {', "\n";
   print '        const uint8_t* samples8 = static_cast<const uint8_t*>(data);', "\n";
   print '        for (size_t i = 0; i < samples; i++) {', "\n";
   print '            audioBuffer_.push_back((samples8[i] - 128) / 128.0f);', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_INFO, "Accumulated " << samples << " samples, total buffer: " << audioBuffer_.size() ', "\n";
   print '              << " samples (" << (audioBuffer_.size() * 1000.0f / sampleRate_) << " ms)", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAudioChunk(const std::vector<float>& audioData)', "\n";
   print '{', "\n";
   print '    // For real-time streaming, this would process chunks as they arrive', "\n";
   print '    // For now, we accumulate in audioBuffer_ and process on window markers', "\n";
   print '    audioBuffer_.insert(audioBuffer_.end(), audioData.begin(), audioData.end());', "\n";
   print '}', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::transcribeAudio(const std::vector<float>& audioData)', "\n";
   print '{', "\n";
   print '    auto start_time = std::chrono::high_resolution_clock::now();', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        // Run inference with NeMo CTC model (handles feature extraction internally)', "\n";
   print '        std::string transcription = nemoSTT_->transcribe(audioData);', "\n";
   print '        ', "\n";
   print '        auto end_time = std::chrono::high_resolution_clock::now();', "\n";
   print '        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);', "\n";
   print '        ', "\n";
   print '        float audio_duration_ms = audioData.size() * 1000.0f / sampleRate_;', "\n";
   print '        float speedup = (duration.count() > 0) ? audio_duration_ms / duration.count() : 0.0f;', "\n";
   print '        ', "\n";
   print '        SPLAPPTRC(L_INFO, "Transcribed " << audio_duration_ms << "ms audio in " ', "\n";
   print '                  << duration.count() << "ms (" << speedup << "x real-time)", SPL_OPER_DBG);', "\n";
   print '        ', "\n";
   print '        return transcription;', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Transcription failed: " << e.what(), SPL_OPER_DBG);', "\n";
   print '        return "";', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::outputTranscription(const std::string& text)', "\n";
   print '{', "\n";
   print '    if (text.empty()) return;', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_INFO, "Transcription: " << text, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Create output tuple', "\n";
   print '    OPort0Type otuple;', "\n";
   print '    ', "\n";
   print '    // Set transcription text (assumes output has \'transcription\' attribute)', "\n";
   print '    otuple.set_transcription(text);', "\n";
   print '    ', "\n";
   print '    // Submit output tuple', "\n";
   print '    submit(otuple, 0);', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
